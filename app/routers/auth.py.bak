from typing import Dict, Optional
from fastapi import APIRouter, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel, EmailStr

# import RELATIVI (una directory sopra → core/ e schemas/)
from ..core.security import (
    hash_password, verify_password,
    create_access_token, create_refresh_token, decode_token,
    REFRESH_EXPIRE_SECONDS
)

# === METADATA per auto-mount ===
ROUTER_PREFIX = "/auth"
ROUTER_TAGS = ["auth"]

router = APIRouter()

# ===== Schemas minimi (oppure importa i tuoi da app/schemas) =====
class RegisterBody(BaseModel):
    email: EmailStr
    password: str
    name: Optional[str] = None

class LoginBody(BaseModel):
    email: EmailStr
    password: str

class RefreshBody(BaseModel):
    refresh_token: Optional[str] = None  # fallback se il cookie non arriva

# ===== DB finto per esempio (sostituisci col tuo) =====
db_users: Dict[str, Dict] = {
    "zoppis@gmail.com": {
        "id": 1, "name": "Mario", "email": "zoppis@gmail.com",
        "password_hash": hash_password("password123"),
    }
}

# ===== Helpers =====
def set_refresh_cookie_on(resp: JSONResponse, token: str):
    resp.set_cookie(
        key="refresh_token",
        value=token,
        httponly=True,
        secure=False,         # metti True in produzione (HTTPS)
        samesite="lax",
        path="/auth/refresh",
        max_age=REFRESH_EXPIRE_SECONDS,
    )

def bearer_token(authorization: Optional[str]) -> Optional[str]:
    if not authorization or not authorization.startswith("Bearer "):
        return None
    return authorization.split(" ", 1)[1]

# ===== Endpoints =====
@router.post("/register")
def register(body: RegisterBody):
    if body.email in db_users:
        raise HTTPException(400, "Email già registrata")
    new_id = max([u["id"] for u in db_users.values()] + [0]) + 1
    db_users[body.email] = {
        "id": new_id,
        "name": body.name or body.email.split("@")[0],
        "email": body.email,
        "password_hash": hash_password(body.password),
    }
    access = create_access_token(str(new_id))
    refresh = create_refresh_token(str(new_id))
    payload = {
        "message": "account creato con successo",
        "access_token": access,
        "refresh_token": refresh,  # fallback per FE senza cookie
        "user": {"id": new_id, "name": db_users[body.email]["name"], "email": body.email},
    }
    resp = JSONResponse(payload)
    set_refresh_cookie_on(resp, refresh)
    return resp

@router.post("/login")
def login(body: LoginBody):
    user = db_users.get(body.email)
    if not user or not verify_password(body.password, user["password_hash"]):
        raise HTTPException(401, "Credenziali non valide")
    access = create_access_token(str(user["id"]))
    refresh = create_refresh_token(str(user["id"]))
    payload = {
        "access_token": access,
        "refresh_token": refresh,  # fallback
        "user": {"id": user["id"], "name": user["name"], "email": user["email"]},
    }
    resp = JSONResponse(payload)
    set_refresh_cookie_on(resp, refresh)
    return resp

@router.post("/refresh")
def refresh(request: Request, body: Optional[RefreshBody] = None):
    rt = request.cookies.get("refresh_token")
    if not rt and body and body.refresh_token:
        rt = body.refresh_token
    if not rt:
        raise HTTPException(401, "missing refresh_token (cookie or body)")

    payload = decode_token(rt)
    if not payload:
        raise HTTPException(401, "invalid/expired refresh token")

    uid = str(payload["sub"])
    access = create_access_token(uid)
    new_rt = create_refresh_token(uid)  # rotazione ad ogni uso

    resp = JSONResponse({"access_token": access, "refresh_rotated": True})
    set_refresh_cookie_on(resp, new_rt)
    return resp

@router.get("/me")
def me(request: Request):
    tok = bearer_token(request.headers.get("Authorization"))
    if not tok:
        raise HTTPException(401, "Authorization mancante")
    payload = decode_token(tok)
    if not payload:
        raise HTTPException(401, "access token non valido/scaduto")
    uid = int(payload["sub"])
    for u in db_users.values():
        if u["id"] == uid:
            return {"id": u["id"], "name": u["name"], "email": u["email"]}
    raise HTTPException(404, "Utente non trovato")

@router.post("/logout")
def logout():
    resp = JSONResponse({"ok": True})
    resp.delete_cookie("refresh_token", path="/auth/refresh")
    return resp
